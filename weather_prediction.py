# -*- coding: utf-8 -*-
"""Weather prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10lUOWj0DXSD9Vrc2UCCBsJKQnigrnRNE
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import paho.mqtt.client as mqtt
import requests

import json

# === Cấu hình ThingsBoard Cloud ===
THINGSBOARD_HOST = "app.coreiot.io"
THINGSBOARD_PORT = 1883
ACCESS_TOKEN = "mze9614291gw4wsthfrz"  # Thay bằng access token của thiết bị trên ThingsBoard
JWT_TOKEN = "Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJtaW5oLnBoYW0yMjEyMDc1QGhjbXV0LmVkdS52biIsInVzZXJJZCI6IjY0ZWNiYzcwLWVkOGUtMTFlZi04N2I1LTIxYmNjZjdkMjlkNSIsInNjb3BlcyI6WyJURU5BTlRfQURNSU4iXSwic2Vzc2lvbklkIjoiYTMwODg5NTAtMzVhYy00OGYzLTg4NDAtOTVmZjZhMmNhMzJhIiwiZXhwIjoxNzQ5MDIzNDc0LCJpc3MiOiJjb3JlaW90LmlvIiwiaWF0IjoxNzQ5MDE0NDc0LCJmaXJzdE5hbWUiOiJNSU5IIiwibGFzdE5hbWUiOiJQSOG6oE0gUVVBTkciLCJlbmFibGVkIjp0cnVlLCJpc1B1YmxpYyI6ZmFsc2UsInRlbmFudElkIjoiNjRlMzZkYTAtZWQ4ZS0xMWVmLTg3YjUtMjFiY2NmN2QyOWQ1IiwiY3VzdG9tZXJJZCI6IjEzODE0MDAwLTFkZDItMTFiMi04MDgwLTgwODA4MDgwODA4MCJ9.6X5LjKZoxwvJXr6VUrHe3ONWqo2KMwoohHeOFbWce_nG1d-sXOF1DxYYolhQ27pbbMmguYYj83KAQHRI5Q-GXA"
DEVICE_ID = "eb308820-ed8e-11ef-87b5-21bccf7d29d5"  # Thay bằng deviceId của thiết bị trên ThingsBoard

def get_latest_telemetry(key: str, jwt_token: str, device_id: str):
  """
  Lấy giá trị telemetry mới nhất qua REST API (cần JWT token và deviceId).
  """
  url = f"https://{THINGSBOARD_HOST}/api/plugins/telemetry/DEVICE/{device_id}/values/timeseries?keys={key}"
  headers = {
    "X-Authorization": f"{jwt_token}"
  }
  try:
      resp = requests.get(url, headers=headers, timeout=5)
      resp.raise_for_status()
      data = resp.json()
      # Dữ liệu trả về dạng: {"temperature": [{"ts":..., "value":...}], ...}
      if key in data and isinstance(data[key], list) and data[key]:
          return data[key][0].get("value")
      else:
          print(f"Không tìm thấy telemetry '{key}'")
          return None
  except Exception as e:
      print(f"Lỗi lấy dữ liệu telemetry '{key}': {e}")
      return None

def get_temperature():
  """
  Lấy giá trị temperature telemetry mới nhất.
  """
  return get_latest_telemetry("temperature", JWT_TOKEN, DEVICE_ID)

def get_humidity():
  """
  Lấy giá trị humidity telemetry mới nhất.
  """
  return get_latest_telemetry("humidity", JWT_TOKEN, DEVICE_ID)

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("Đã kết nối tới ThingsBoard Cloud MQTT Broker")
    else:
        print(f"Kết nối lỗi, mã trả về: {rc}")

from itertools import chain
def Create_list(x):
    list_of_lists=[w.split() for w in x.split(',')]
    flat_list=list(chain(*list_of_lists))
    return flat_list


def Get_Weather(list1):
    if 'Cloudy' in list1:
      return 'CLOUDY'
    elif 'Rainy' in list1:
      return 'RAINY'
    elif 'Sunny' in list1:
      return 'SUNNY'
    elif 'Clear' in list1:
      return 'CLEAR'

def result():
  # === MQTT client setup ===
  client = mqtt.Client()
  client.username_pw_set(ACCESS_TOKEN)

  client.on_connect = on_connect

  client.connect(THINGSBOARD_HOST, THINGSBOARD_PORT)
  client.loop_start()

  data=pd.read_csv('HCM_Dataset.csv')
  data.head()

  data.shape

  data.dtypes

  data.info()

  data.Weather.value_counts()

  data.Weather.unique()

  data.Weather.nunique()

  x='Cloudy'
  Create_list(x)

  Get_Weather(Create_list(x))

  data['Std_Weather']=data['Weather'].apply(lambda x: Get_Weather(Create_list(x)))

  data.head()

  data.Std_Weather.value_counts()

  cloudy_df=data[data['Std_Weather']=='CLOUDY'].sample(1500)
  cloudy_df.shape

  rainy_df=data[data['Std_Weather']=='RAINY'].sample(1500)
  rainy_df.shape

  clear_df=data[data['Std_Weather']=='CLEAR'].sample(1500)
  clear_df.shape

  sunny_df=data[data['Std_Weather']=='SUNNY']
  sunny_df.shape



  weather_df=pd.concat([cloudy_df,clear_df,rainy_df, sunny_df],axis=0)
  weather_df.head()

  weather_df.shape

  weather_df.Std_Weather.value_counts()

  """drop columns date+weather"""

  weather_df.drop(columns=['Date/Time','Weather', 'Temperature'], axis=1, inplace=True)

  weather_df.head()

  weather_df[weather_df.duplicated()]

  weather_df.isnull().sum()

  weather_df.dtypes

  """Visualizations"""

  weather_df.describe()

  cols=['Humidity', 'Temperature_C']

  cor_matrix=weather_df[cols].corr()
  cor_matrix

  sns.heatmap(cor_matrix, annot=True)

  weather_df.columns

  weather_df['Temperature_C'].plot(kind='hist')

  weather_df.head()

  """Label encoding (convert targer var into numeric)"""

  from sklearn.preprocessing import LabelEncoder

  label_Encoder=LabelEncoder()

  weather_df['Std_Weather']=label_Encoder.fit_transform(weather_df['Std_Weather'])

  label_Encoder.classes_

  cat_code=dict(zip(label_Encoder.classes_, label_Encoder.transform(label_Encoder.classes_)))
  cat_code

  weather_df.head()

  weather_df.Std_Weather.value_counts()

  """x,y var"""

  X=weather_df.drop(['Std_Weather'],axis=1)
  X
  # independent var

  #targer var
  y=weather_df['Std_Weather']
  y

  """feature scaling"""

  from sklearn.preprocessing import StandardScaler

  std_scaler=StandardScaler()

  X_std=std_scaler.fit_transform(X)
  X_std

  """split data into train and test"""

  from sklearn.model_selection import train_test_split

  x_train, x_test, y_train, y_test= train_test_split(X_std, y, test_size=0.2, random_state=42)

  x_train.shape, x_test.shape

  """Model building using Decision Tree"""

  from sklearn.tree import DecisionTreeClassifier
  decision_tree_model = DecisionTreeClassifier()

  """model training"""

  decision_tree_model.fit(x_train, y_train)

  """model prediction"""

  y_pred_dt=decision_tree_model.predict(x_test)

  """model eval"""

  from sklearn.metrics import accuracy_score
  from sklearn.metrics import classification_report
  from sklearn.metrics import confusion_matrix

  accuracy_score(y_test, y_pred_dt)

  print(classification_report(y_test, y_pred_dt))

  cm=confusion_matrix(y_test, y_pred_dt)
  sns.heatmap(cm, annot=True, fmt='d')

  """Build multiple models -> best model"""

  from sklearn.tree import DecisionTreeClassifier
  from sklearn.ensemble import RandomForestClassifier
  from sklearn.svm import SVC
  from sklearn.neighbors import KNeighborsClassifier
  from sklearn.linear_model import LogisticRegression
  from sklearn.naive_bayes import GaussianNB

  dt_model=DecisionTreeClassifier()
  rf_model=RandomForestClassifier()
  svc_model=SVC()
  knn_model=KNeighborsClassifier()
  lr_model=LogisticRegression()
  nb_model=GaussianNB()

  model_list=[dt_model, rf_model, svc_model, knn_model, lr_model, nb_model]

  acc_list=[]
  for model in model_list:
      model.fit(x_train, y_train)
      y_pred=model.predict(x_test)
      acc=accuracy_score(y_test, y_pred)
      acc_list.append(acc)

  acc_list

  model_df=pd.DataFrame({'Model':model_list, 'Accuracy':acc_list})
  model_df

  """K-fold cross validation"""

  from sklearn.model_selection import cross_val_score
  scores=cross_val_score(rf_model, X_std, y, cv=5, scoring='accuracy')
  print('Cross-validation scores=',scores)

  scores.mean()

  """Hyperparameter tuning"""

  from sklearn.model_selection import GridSearchCV, RandomizedSearchCV

  parameters={
      'n_estimators': [50,100],
      'max_features': ['sqrt', 'log2', None]
  }

  grid_search=GridSearchCV(estimator=rf_model, param_grid=parameters)

  grid_search.fit(x_train, y_train)

  """Best hyper parameters"""

  grid_search.best_params_

  new_rf_model=RandomForestClassifier(max_features='sqrt', n_estimators=100)

  new_rf_model.fit(x_train, y_train)

  y_pred_rf = new_rf_model.predict(x_test)

  accuracy_score(y_test, y_pred_rf)

  from sklearn.model_selection import cross_val_score
  scores=cross_val_score(new_rf_model, X_std, y, cv=5, scoring='accuracy')
  print('Cross-validation scores= ', scores)

  scores.mean()

  Humidity= get_humidity()
  Temperature= get_temperature()
  client.publish('v1/devices/me/telemetry', json.dumps({"humi_input": Humidity, "temp_input": Temperature}))
  print(f"Humidity: {Humidity}, Temperature: {Temperature}")

  input_data=[Humidity,Temperature]
  scaled_data=std_scaler.transform([input_data])
  prediction=new_rf_model.predict(scaled_data)
  prediction

  res_str = ''
  if prediction[0]==0:
    client.publish('v1/devices/me/telemetry', json.dumps({"weather": "CLEAR"}))
    res_str = 'CLEAR'
  elif prediction[0]==1:
    client.publish('v1/devices/me/telemetry', json.dumps({"weather": "CLOUDY"}))
    res_str = 'CLOUDY'
  elif prediction[0]==2:
    client.publish('v1/devices/me/telemetry', json.dumps({"weather": "RAINY"}))
    res_str = 'RAINY'
  else:
    client.publish('v1/devices/me/telemetry', json.dumps({"weather": "SUNNY"}))
    res_str = 'SUNNY'
  
  client.loop_stop()
  return res_str